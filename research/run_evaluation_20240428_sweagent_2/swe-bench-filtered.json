[
    {
        "repo": "pvlib/pvlib-python",
        "instance_id": "pvlib__pvlib-python-807",
        "base_commit": "e326fa53038f616d949e4f981dab6187d2ca9470",
        "patch": "diff --git a/pvlib/scaling.py b/pvlib/scaling.py\nnew file mode 100644\n--- /dev/null\n+++ b/pvlib/scaling.py\n@@ -0,0 +1,242 @@\n+\"\"\"\n+The ``scaling`` module contains functions for manipulating irradiance\n+or other variables to account for temporal or spatial characteristics.\n+\"\"\"\n+\n+import numpy as np\n+import pandas as pd\n+\n+\n+def wvm(clearsky_index, positions, cloud_speed, dt=None):\n+    \"\"\"\n+    Compute spatial aggregation time series smoothing on clear sky index based\n+    on the Wavelet Variability model of Lave et al [1-2]. Implementation is\n+    basically a port of the Matlab version of the code [3].\n+\n+    Parameters\n+    ----------\n+    clearsky_index : numeric or pandas.Series\n+        Clear Sky Index time series that will be smoothed.\n+\n+    positions : numeric\n+        Array of coordinate distances as (x,y) pairs representing the\n+        easting, northing of the site positions in meters [m]. Distributed\n+        plants could be simulated by gridded points throughout the plant\n+        footprint.\n+\n+    cloud_speed : numeric\n+        Speed of cloud movement in meters per second [m/s].\n+\n+    dt : float, default None\n+        The time series time delta. By default, is inferred from the\n+        clearsky_index. Must be specified for a time series that doesn't\n+        include an index. Units of seconds [s].\n+\n+    Returns\n+    -------\n+    smoothed : numeric or pandas.Series\n+        The Clear Sky Index time series smoothed for the described plant.\n+\n+    wavelet: numeric\n+        The individual wavelets for the time series before smoothing.\n+\n+    tmscales: numeric\n+        The timescales associated with the wavelets in seconds [s].\n+\n+    References\n+    ----------\n+    [1] M. Lave, J. Kleissl and J.S. Stein. A Wavelet-Based Variability\n+    Model (WVM) for Solar PV Power Plants. IEEE Transactions on Sustainable\n+    Energy, vol. 4, no. 2, pp. 501-509, 2013.\n+\n+    [2] M. Lave and J. Kleissl. Cloud speed impact on solar variability\n+    scaling - Application to the wavelet variability model. Solar Energy,\n+    vol. 91, pp. 11-21, 2013.\n+\n+    [3] Wavelet Variability Model - Matlab Code:\n+    https://pvpmc.sandia.gov/applications/wavelet-variability-model/\n+    \"\"\"\n+\n+    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n+\n+    try:\n+        import scipy.optimize\n+        from scipy.spatial.distance import pdist\n+    except ImportError:\n+        raise ImportError(\"The WVM function requires scipy.\")\n+\n+    pos = np.array(positions)\n+    dist = pdist(pos, 'euclidean')\n+    wavelet, tmscales = _compute_wavelet(clearsky_index, dt)\n+\n+    # Find effective length of position vector, 'dist' is full pairwise\n+    n_pairs = len(dist)\n+\n+    def fn(x):\n+        return np.abs((x ** 2 - x) / 2 - n_pairs)\n+    n_dist = np.round(scipy.optimize.fmin(fn, np.sqrt(n_pairs), disp=False))\n+\n+    # Compute VR\n+    A = cloud_speed / 2  # Resultant fit for A from [2]\n+    vr = np.zeros(tmscales.shape)\n+    for i, tmscale in enumerate(tmscales):\n+        rho = np.exp(-1 / A * dist / tmscale)  # Eq 5 from [1]\n+\n+        # 2*rho is because rho_ij = rho_ji. +n_dist accounts for sum(rho_ii=1)\n+        denominator = 2 * np.sum(rho) + n_dist\n+        vr[i] = n_dist ** 2 / denominator  # Eq 6 of [1]\n+\n+    # Scale each wavelet by VR (Eq 7 in [1])\n+    wavelet_smooth = np.zeros_like(wavelet)\n+    for i in np.arange(len(tmscales)):\n+        if i < len(tmscales) - 1:  # Treat the lowest freq differently\n+            wavelet_smooth[i, :] = wavelet[i, :] / np.sqrt(vr[i])\n+        else:\n+            wavelet_smooth[i, :] = wavelet[i, :]\n+\n+    outsignal = np.sum(wavelet_smooth, 0)\n+\n+    try:  # See if there's an index already, if so, return as a pandas Series\n+        smoothed = pd.Series(outsignal, index=clearsky_index.index)\n+    except AttributeError:\n+        smoothed = outsignal  # just output the numpy signal\n+\n+    return smoothed, wavelet, tmscales\n+\n+\n+def latlon_to_xy(coordinates):\n+    \"\"\"\n+    Convert latitude and longitude in degrees to a coordinate system measured\n+    in meters from zero deg latitude, zero deg longitude.\n+\n+    This is a convenience method to support inputs to wvm. Note that the\n+    methodology used is only suitable for short distances. For conversions of\n+    longer distances, users should consider use of Universal Transverse\n+    Mercator (UTM) or other suitable cartographic projection. Consider\n+    packages built for cartographic projection such as pyproj (e.g.\n+    pyproj.transform()) [2].\n+\n+    Parameters\n+    ----------\n+\n+    coordinates : numeric\n+        Array or list of (latitude, longitude) coordinate pairs. Use decimal\n+        degrees notation.\n+\n+    Returns\n+    -------\n+    xypos : numeric\n+        Array of coordinate distances as (x,y) pairs representing the\n+        easting, northing of the position in meters [m].\n+\n+    References\n+    ----------\n+    [1] H. Moritz. Geodetic Reference System 1980, Journal of Geodesy, vol. 74,\n+    no. 1, pp 128\u2013133, 2000.\n+\n+    [2] https://pypi.org/project/pyproj/\n+\n+    [3] Wavelet Variability Model - Matlab Code:\n+    https://pvpmc.sandia.gov/applications/wavelet-variability-model/\n+    \"\"\"\n+\n+    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n+\n+    r_earth = 6371008.7714  # mean radius of Earth, in meters\n+    m_per_deg_lat = r_earth * np.pi / 180\n+    try:\n+        meanlat = np.mean([lat for (lat, lon) in coordinates])  # Mean latitude\n+    except TypeError:  # Assume it's a single value?\n+        meanlat = coordinates[0]\n+    m_per_deg_lon = r_earth * np.cos(np.pi/180 * meanlat) * np.pi/180\n+\n+    # Conversion\n+    pos = coordinates * np.array(m_per_deg_lat, m_per_deg_lon)\n+\n+    # reshape as (x,y) pairs to return\n+    try:\n+        return np.column_stack([pos[:, 1], pos[:, 0]])\n+    except IndexError:  # Assume it's a single value, which has a 1D shape\n+        return np.array((pos[1], pos[0]))\n+\n+\n+def _compute_wavelet(clearsky_index, dt=None):\n+    \"\"\"\n+    Compute the wavelet transform on the input clear_sky time series.\n+\n+    Parameters\n+    ----------\n+    clearsky_index : numeric or pandas.Series\n+        Clear Sky Index time series that will be smoothed.\n+\n+    dt : float, default None\n+        The time series time delta. By default, is inferred from the\n+        clearsky_index. Must be specified for a time series that doesn't\n+        include an index. Units of seconds [s].\n+\n+    Returns\n+    -------\n+    wavelet: numeric\n+        The individual wavelets for the time series\n+\n+    tmscales: numeric\n+        The timescales associated with the wavelets in seconds [s]\n+\n+    References\n+    ----------\n+    [1] M. Lave, J. Kleissl and J.S. Stein. A Wavelet-Based Variability\n+    Model (WVM) for Solar PV Power Plants. IEEE Transactions on Sustainable\n+    Energy, vol. 4, no. 2, pp. 501-509, 2013.\n+\n+    [3] Wavelet Variability Model - Matlab Code:\n+    https://pvpmc.sandia.gov/applications/wavelet-variability-model/\n+    \"\"\"\n+\n+    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n+\n+    try:  # Assume it's a pandas type\n+        vals = clearsky_index.values.flatten()\n+    except AttributeError:  # Assume it's a numpy type\n+        vals = clearsky_index.flatten()\n+        if dt is None:\n+            raise ValueError(\"dt must be specified for numpy type inputs.\")\n+    else:  # flatten() succeeded, thus it's a pandas type, so get its dt\n+        try:  # Assume it's a time series type index\n+            dt = (clearsky_index.index[1] - clearsky_index.index[0]).seconds\n+        except AttributeError:  # It must just be a numeric index\n+            dt = (clearsky_index.index[1] - clearsky_index.index[0])\n+\n+    # Pad the series on both ends in time and place in a dataframe\n+    cs_long = np.pad(vals, (len(vals), len(vals)), 'symmetric')\n+    cs_long = pd.DataFrame(cs_long)\n+\n+    # Compute wavelet time scales\n+    min_tmscale = np.ceil(np.log(dt)/np.log(2))  # Minimum wavelet timescale\n+    max_tmscale = int(12 - min_tmscale)  # maximum wavelet timescale\n+\n+    tmscales = np.zeros(max_tmscale)\n+    csi_mean = np.zeros([max_tmscale, len(cs_long)])\n+    # Loop for all time scales we will consider\n+    for i in np.arange(0, max_tmscale):\n+        j = i+1\n+        tmscales[i] = 2**j * dt  # Wavelet integration time scale\n+        intvlen = 2**j  # Wavelet integration time series interval\n+        # Rolling average, retains only lower frequencies than interval\n+        df = cs_long.rolling(window=intvlen, center=True, min_periods=1).mean()\n+        # Fill nan's in both directions\n+        df = df.fillna(method='bfill').fillna(method='ffill')\n+        # Pop values back out of the dataframe and store\n+        csi_mean[i, :] = df.values.flatten()\n+\n+    # Calculate the wavelets by isolating the rolling mean frequency ranges\n+    wavelet_long = np.zeros(csi_mean.shape)\n+    for i in np.arange(0, max_tmscale-1):\n+        wavelet_long[i, :] = csi_mean[i, :] - csi_mean[i+1, :]\n+    wavelet_long[max_tmscale-1, :] = csi_mean[max_tmscale-1, :]  # Lowest freq\n+\n+    # Clip off the padding and just return the original time window\n+    wavelet = np.zeros([max_tmscale, len(vals)])\n+    for i in np.arange(0, max_tmscale):\n+        wavelet[i, :] = wavelet_long[i, len(vals)+1: 2*len(vals)+1]\n+\n+    return wavelet, tmscales\n",
        "test_patch": "diff --git a/pvlib/test/test_scaling.py b/pvlib/test/test_scaling.py\nnew file mode 100644\n--- /dev/null\n+++ b/pvlib/test/test_scaling.py\n@@ -0,0 +1,146 @@\n+import numpy as np\n+import pandas as pd\n+\n+import pytest\n+from numpy.testing import assert_almost_equal\n+\n+from pvlib import scaling\n+from conftest import requires_scipy\n+\n+\n+# Sample cloud speed\n+cloud_speed = 5\n+\n+# Sample dt\n+dt = 1\n+\n+\n+@pytest.fixture\n+def coordinates():\n+    # Sample positions in lat/lon\n+    lat = np.array((9.99, 10, 10.01))\n+    lon = np.array((4.99, 5, 5.01))\n+    coordinates = np.array([(lati, loni) for (lati, loni) in zip(lat, lon)])\n+    return coordinates\n+\n+\n+@pytest.fixture\n+def clear_sky_index():\n+    # Generate a sample clear_sky_index\n+    clear_sky_index = np.ones(10000)\n+    clear_sky_index[5000:5005] = np.array([1, 1, 1.1, 0.9, 1])\n+    return clear_sky_index\n+\n+\n+@pytest.fixture\n+def time(clear_sky_index):\n+    # Sample time vector\n+    return np.arange(0, len(clear_sky_index))\n+\n+\n+@pytest.fixture\n+def positions():\n+    # Sample positions based on the previous lat/lon (calculated manually)\n+    expect_xpos = np.array([554863.4, 555975.4, 557087.3])\n+    expect_ypos = np.array([1110838.8, 1111950.8, 1113062.7])\n+    return np.array([pt for pt in zip(expect_xpos, expect_ypos)])\n+\n+\n+@pytest.fixture\n+def expect_tmscale():\n+    # Expected timescales for dt = 1\n+    return [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]\n+\n+\n+@pytest.fixture\n+def expect_wavelet():\n+    # Expected wavelet for indices 5000:5004 for clear_sky_index above (Matlab)\n+    return np.array([[-0.025, 0.05, 0., -0.05, 0.025],\n+                     [0.025, 0., 0., 0., -0.025],\n+                     [0., 0., 0., 0., 0.]])\n+\n+\n+@pytest.fixture\n+def expect_cs_smooth():\n+    # Expected smoothed clear sky index for indices 5000:5004 (Matlab)\n+    return np.array([1., 1.0289, 1., 0.9711, 1.])\n+\n+\n+def test_latlon_to_xy_zero():\n+    coord = [0, 0]\n+    pos_e = [0, 0]\n+    pos = scaling.latlon_to_xy(coord)\n+    assert_almost_equal(pos, pos_e, decimal=1)\n+\n+\n+def test_latlon_to_xy_single(coordinates, positions):\n+    # Must test against central value, because latlon_to_xy uses the mean\n+    coord = coordinates[1]\n+    pos = scaling.latlon_to_xy(coord)\n+    assert_almost_equal(pos, positions[1], decimal=1)\n+\n+\n+def test_latlon_to_xy_array(coordinates, positions):\n+    pos = scaling.latlon_to_xy(coordinates)\n+    assert_almost_equal(pos, positions, decimal=1)\n+\n+\n+def test_latlon_to_xy_list(coordinates, positions):\n+    pos = scaling.latlon_to_xy(coordinates.tolist())\n+    assert_almost_equal(pos, positions, decimal=1)\n+\n+\n+def test_compute_wavelet_series(clear_sky_index, time,\n+                                expect_tmscale, expect_wavelet):\n+    csi_series = pd.Series(clear_sky_index, index=time)\n+    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n+    assert_almost_equal(tmscale, expect_tmscale)\n+    assert_almost_equal(wavelet[0:3, 5000:5005], expect_wavelet)\n+\n+\n+def test_compute_wavelet_series_numindex(clear_sky_index, time,\n+                                         expect_tmscale, expect_wavelet):\n+    dtindex = pd.to_datetime(time, unit='s')\n+    csi_series = pd.Series(clear_sky_index, index=dtindex)\n+    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n+    assert_almost_equal(tmscale, expect_tmscale)\n+    assert_almost_equal(wavelet[0:3, 5000:5005], expect_wavelet)\n+\n+\n+def test_compute_wavelet_array(clear_sky_index,\n+                               expect_tmscale, expect_wavelet):\n+    wavelet, tmscale = scaling._compute_wavelet(clear_sky_index, dt)\n+    assert_almost_equal(tmscale, expect_tmscale)\n+    assert_almost_equal(wavelet[0:3, 5000:5005], expect_wavelet)\n+\n+\n+def test_compute_wavelet_array_invalid(clear_sky_index):\n+    with pytest.raises(ValueError):\n+        scaling._compute_wavelet(clear_sky_index)\n+\n+\n+@requires_scipy\n+def test_wvm_series(clear_sky_index, time, positions, expect_cs_smooth):\n+    csi_series = pd.Series(clear_sky_index, index=time)\n+    cs_sm, _, _ = scaling.wvm(csi_series, positions, cloud_speed)\n+    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n+\n+\n+@requires_scipy\n+def test_wvm_array(clear_sky_index, positions, expect_cs_smooth):\n+    cs_sm, _, _ = scaling.wvm(clear_sky_index, positions, cloud_speed, dt=dt)\n+    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n+\n+\n+@requires_scipy\n+def test_wvm_series_xyaslist(clear_sky_index, time, positions,\n+                             expect_cs_smooth):\n+    csi_series = pd.Series(clear_sky_index, index=time)\n+    cs_sm, _, _ = scaling.wvm(csi_series, positions.tolist(), cloud_speed)\n+    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n+\n+\n+@requires_scipy\n+def test_wvm_invalid(clear_sky_index, positions):\n+    with pytest.raises(ValueError):\n+        scaling.wvm(clear_sky_index, positions, cloud_speed)\n",
        "problem_statement": "Add Wavelet Variability Model (WVM) for calculating spatial smoothing of irradiance\n> > Should I spin this off to a separate issue, since it might be different (and more compartmented) than the broader downscaling discussion?\r\n> \r\n> Yes. Let's start a new module with this submission, `scaling.py` comes to mind, but I'm not enamored of it. Scope will be functions that operate on irradiance, perhaps other variables, to transform temporal or spatial characteristics.\r\n\r\nSpinoff from [issue #788 ](https://github.com/pvlib/pvlib-python/issues/788). Implementation is a python port of WVM, released as an auxiliary to the Matlab pvlib [here](https://pvpmc.sandia.gov/applications/wavelet-variability-model/). My implementation ports the original model logic, but deviates from the overall package, in that I begin at the point where the user already has a clear sky index to operate on (original starts from GHI and calculates POA clear sky index). I thought this would allow for more flexibility in choice of transposition model, etc, but it does ask a bit more work up front for a user to run the WVM.\r\n\r\nI am close to completion of a draft and will create a pull request when ready. This is my first contribution to the project (or any open source project really), so please accept my apologies in advance if it takes some guidance.\n",
        "hints_text": "> This is my first contribution to the project (or any open source project really), so please accept my apologies in advance if it takes some guidance.\r\n\r\nWelcome!  Asking for a clear-sky index as input seems appropriate; there's no need to rigidly follow the MATLAB implementation. I'll ask for your patience with the review process, which can involve multiple iterations and reviewers.",
        "created_at": "2019-11-01T14:54:52Z",
        "version": "0.6",
        "FAIL_TO_PASS": [
            "pvlib/test/test_scaling.py::test_latlon_to_xy_zero",
            "pvlib/test/test_scaling.py::test_latlon_to_xy_single",
            "pvlib/test/test_scaling.py::test_latlon_to_xy_array",
            "pvlib/test/test_scaling.py::test_latlon_to_xy_list",
            "pvlib/test/test_scaling.py::test_compute_wavelet_series",
            "pvlib/test/test_scaling.py::test_compute_wavelet_series_numindex",
            "pvlib/test/test_scaling.py::test_compute_wavelet_array",
            "pvlib/test/test_scaling.py::test_compute_wavelet_array_invalid",
            "pvlib/test/test_scaling.py::test_wvm_series",
            "pvlib/test/test_scaling.py::test_wvm_array",
            "pvlib/test/test_scaling.py::test_wvm_series_xyaslist",
            "pvlib/test/test_scaling.py::test_wvm_invalid"
        ],
        "PASS_TO_PASS": [],
        "environment_setup_commit": "b91d178868d193afd56f8e3b013661a473d699c3"
    }
]